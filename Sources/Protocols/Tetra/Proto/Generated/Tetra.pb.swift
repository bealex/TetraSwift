// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Tetra.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct IntegerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameter: Int32 = 0

  var value: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CharacterData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameter: Int32 = 0

  var value: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StringData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var parameter: Int32 = 0

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClientCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  var handshake: ClientCommand.Handshake {
    get {
      if case .handshake(let v)? = _storage._data {return v}
      return ClientCommand.Handshake()
    }
    set {_uniqueStorage()._data = .handshake(newValue)}
  }

  var actuator: ClientCommand.Actuator {
    get {
      if case .actuator(let v)? = _storage._data {return v}
      return ClientCommand.Actuator()
    }
    set {_uniqueStorage()._data = .actuator(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case handshake(ClientCommand.Handshake)
    case actuator(ClientCommand.Actuator)

  #if !swift(>=4.1)
    static func ==(lhs: ClientCommand.OneOf_Data, rhs: ClientCommand.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.handshake(let l), .handshake(let r)): return l == r
      case (.actuator(let l), .actuator(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  struct Handshake {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Actuator {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var port: Int32 {
      get {return _storage._port}
      set {_uniqueStorage()._port = newValue}
    }

    var data: OneOf_Data? {
      get {return _storage._data}
      set {_uniqueStorage()._data = newValue}
    }

    var integer: IntegerData {
      get {
        if case .integer(let v)? = _storage._data {return v}
        return IntegerData()
      }
      set {_uniqueStorage()._data = .integer(newValue)}
    }

    var character: CharacterData {
      get {
        if case .character(let v)? = _storage._data {return v}
        return CharacterData()
      }
      set {_uniqueStorage()._data = .character(newValue)}
    }

    var string: StringData {
      get {
        if case .string(let v)? = _storage._data {return v}
        return StringData()
      }
      set {_uniqueStorage()._data = .string(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Data: Equatable {
      case integer(IntegerData)
      case character(CharacterData)
      case string(StringData)

    #if !swift(>=4.1)
      static func ==(lhs: ClientCommand.Actuator.OneOf_Data, rhs: ClientCommand.Actuator.OneOf_Data) -> Bool {
        switch (lhs, rhs) {
        case (.integer(let l), .integer(let r)): return l == r
        case (.character(let l), .character(let r)): return l == r
        case (.string(let l), .string(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ArduinoCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Configuration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ports: [ArduinoCommand.Configuration] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct PortInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var port: Int32 = 0

      var type: ArduinoCommand.Configuration.PortInfo.TypeEnum = .unknown

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknown // = 0
        case inputAnalog // = 1
        case inputDigital // = 2
        case outputAnalog // = 3
        case outputDigital // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .inputAnalog
          case 2: self = .inputDigital
          case 3: self = .outputAnalog
          case 4: self = .outputDigital
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .inputAnalog: return 1
          case .inputDigital: return 2
          case .outputAnalog: return 3
          case .outputDigital: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    init() {}
  }

  struct Sensors {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: [ArduinoCommand.Sensors.Sensor] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Sensor {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var port: Int32 {
        get {return _storage._port}
        set {_uniqueStorage()._port = newValue}
      }

      var data: OneOf_Data? {
        get {return _storage._data}
        set {_uniqueStorage()._data = newValue}
      }

      var integer: IntegerData {
        get {
          if case .integer(let v)? = _storage._data {return v}
          return IntegerData()
        }
        set {_uniqueStorage()._data = .integer(newValue)}
      }

      var character: CharacterData {
        get {
          if case .character(let v)? = _storage._data {return v}
          return CharacterData()
        }
        set {_uniqueStorage()._data = .character(newValue)}
      }

      var string: StringData {
        get {
          if case .string(let v)? = _storage._data {return v}
          return StringData()
        }
        set {_uniqueStorage()._data = .string(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Data: Equatable {
        case integer(IntegerData)
        case character(CharacterData)
        case string(StringData)

      #if !swift(>=4.1)
        static func ==(lhs: ArduinoCommand.Sensors.Sensor.OneOf_Data, rhs: ArduinoCommand.Sensors.Sensor.OneOf_Data) -> Bool {
          switch (lhs, rhs) {
          case (.integer(let l), .integer(let r)): return l == r
          case (.character(let l), .character(let r)): return l == r
          case (.string(let l), .string(let r)): return l == r
          default: return false
          }
        }
      #endif
      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension IntegerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "IntegerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameter"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.parameter)
      case 2: try decoder.decodeSingularInt32Field(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parameter != 0 {
      try visitor.visitSingularInt32Field(value: self.parameter, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IntegerData, rhs: IntegerData) -> Bool {
    if lhs.parameter != rhs.parameter {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CharacterData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CharacterData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameter"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.parameter)
      case 2: try decoder.decodeSingularInt32Field(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parameter != 0 {
      try visitor.visitSingularInt32Field(value: self.parameter, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CharacterData, rhs: CharacterData) -> Bool {
    if lhs.parameter != rhs.parameter {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StringData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StringData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameter"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.parameter)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.parameter != 0 {
      try visitor.visitSingularInt32Field(value: self.parameter, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StringData, rhs: StringData) -> Bool {
    if lhs.parameter != rhs.parameter {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClientCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handshake"),
    2: .same(proto: "actuator"),
  ]

  fileprivate class _StorageClass {
    var _data: ClientCommand.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: ClientCommand.Handshake?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .handshake(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .handshake(v)}
        case 2:
          var v: ClientCommand.Actuator?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .actuator(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .actuator(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._data {
      case .handshake(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .actuator(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClientCommand, rhs: ClientCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientCommand.Handshake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ClientCommand.protoMessageName + ".Handshake"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClientCommand.Handshake, rhs: ClientCommand.Handshake) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientCommand.Actuator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ClientCommand.protoMessageName + ".Actuator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
    2: .same(proto: "integer"),
    3: .same(proto: "character"),
    4: .same(proto: "string"),
  ]

  fileprivate class _StorageClass {
    var _port: Int32 = 0
    var _data: ClientCommand.Actuator.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _port = source._port
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._port)
        case 2:
          var v: IntegerData?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .integer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .integer(v)}
        case 3:
          var v: CharacterData?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .character(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .character(v)}
        case 4:
          var v: StringData?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .string(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .string(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._port != 0 {
        try visitor.visitSingularInt32Field(value: _storage._port, fieldNumber: 1)
      }
      switch _storage._data {
      case .integer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .character(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .string(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClientCommand.Actuator, rhs: ClientCommand.Actuator) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._port != rhs_storage._port {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArduinoCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ArduinoCommand"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ArduinoCommand, rhs: ArduinoCommand) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArduinoCommand.Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ArduinoCommand.protoMessageName + ".Configuration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ports"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ports)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ports, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ArduinoCommand.Configuration, rhs: ArduinoCommand.Configuration) -> Bool {
    if lhs.ports != rhs.ports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArduinoCommand.Configuration.PortInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ArduinoCommand.Configuration.protoMessageName + ".PortInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.port)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ArduinoCommand.Configuration.PortInfo, rhs: ArduinoCommand.Configuration.PortInfo) -> Bool {
    if lhs.port != rhs.port {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArduinoCommand.Configuration.PortInfo.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "unknown"),
    1: .same(proto: "inputAnalog"),
    2: .same(proto: "inputDigital"),
    3: .same(proto: "outputAnalog"),
    4: .same(proto: "outputDigital"),
  ]
}

extension ArduinoCommand.Sensors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ArduinoCommand.protoMessageName + ".Sensors"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ArduinoCommand.Sensors, rhs: ArduinoCommand.Sensors) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArduinoCommand.Sensors.Sensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = ArduinoCommand.Sensors.protoMessageName + ".Sensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
    2: .same(proto: "integer"),
    3: .same(proto: "character"),
    4: .same(proto: "string"),
  ]

  fileprivate class _StorageClass {
    var _port: Int32 = 0
    var _data: ArduinoCommand.Sensors.Sensor.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _port = source._port
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._port)
        case 2:
          var v: IntegerData?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .integer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .integer(v)}
        case 3:
          var v: CharacterData?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .character(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .character(v)}
        case 4:
          var v: StringData?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .string(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .string(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._port != 0 {
        try visitor.visitSingularInt32Field(value: _storage._port, fieldNumber: 1)
      }
      switch _storage._data {
      case .integer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .character(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .string(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ArduinoCommand.Sensors.Sensor, rhs: ArduinoCommand.Sensors.Sensor) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._port != rhs_storage._port {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
